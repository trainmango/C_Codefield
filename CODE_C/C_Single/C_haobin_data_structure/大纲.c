/* 
    2023年2月11日18点24分
    数据结构入门

    数据结构概述
           定义
               我们如何把显示中大量而复杂的问题以特定的数据类型和特定的
               存储结构保存到主存储器（内存）中，以及在此基础上为实现某
               个功能（比如查找某个元素，删除某个元素，对所有元素进行排
               序）而执行的相应操作，这个相应的操作也叫算法
              
              数据结构 = 个体 +个体关系
              算法 = 对存储数据的操作

           算法
               解题的方法和步骤


               衡量算法的标准
                        1.时间复杂度
                             大概程序要执行的次数，而非执行的时间
                        2.空间复杂度
                             算法执行过程中大概所占用的最大内存
                        3.难易程度

                        4.健壮性 

    数据结构的地位
           数据结构是软件中最核心的课程
           程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言

    预备知识
        指针
           指针的重要性
                  指针是C语言的灵魂
            定义
                地址
                    内存单元的编号
                    从0开始的非负整数
                    范围：0~FFFFFFFF【0~4G-1】（以4G的内存条为例）
                指针
                    指针就是地址，地址就是指针
                    指针变量是存放内存单元地址的变量
                    指针的本质是一个操作受限的非负整数
                分类 
                    1.基本类型指针

                    2.指针和数组的关系 

        结构体
            为什么会出现结构体
                    为了表示一些复杂的数据，而普通的基本类型变量无法满足要求

            什么叫结构体
                    结构体手机用户根据实际需要自己定义的复合数据类型

            如何使用结构体
                  两种方式  1.  struct Student st = {1000, "zhangsan", 20};
                            2.  struct Student * pst;
                    【1】 st.sid
                    【2】 pst->sid  //pst所指向的结构体变量中的sid这个成员
                                      
            注意事项
               结构体变量不能加减乘除，但可以相互赋值
               普通结构体变量和结构体指针变量作为函数传参的问题

        动态内存的分配和释放
    
    模块一： 线性结构 【把所有的结点用一根直线穿起来】

        连续存储[数组]
           1.什么叫数组
              元素类型相同，大小相等
           2.数组的优缺点：

        离散存储[链表]
           定义：
              n个结点离散分配
              彼此通过指针相连
              每个节点只有一个前驱节点，首节点没有前驱节点，首节点没有后续节点
              
              专业术语：
                    首节点：
                          第一个有效的结点
                    尾节点：
                          最后一个有效结点
                    头节点：
                          头节点的数据类型和首节点类型一样
                          第一个有效节点之前的那个结点
                          头节点并不存放有效数据
                          加头结点的目的主要是为了方便对链表的操作
                    头指针：
                          指向头节点的指针变量（存放了头节点的地址）
                    尾指针：
                          指向尾节点的指针变量

              如果希望通过一个函数来对链表进行处理，我们至少需要接受链表的哪些信息：
                      只需要一个参数，头指针
                      因为我们通过头指针可以推算出链表的其他所有参数


           分类:
                单链表：

                双链表：
                     每个结点有两个指针域
                循环链表：
                     能通过任何一个结点找到其他所有的结点
                非循环链表：
                     
           算法：
                遍历
                查找
                清空
                销毁
                求长度
                排序
                删除结点
                插入结点

                算法：
                   狭义的算法是于数据的存储方式密切相关
                   广义的算法是于数据的存储方式无关
                泛型：
                   利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的

           链表的优缺点：
            

        线性结构的两种常见应用之一 栈
           定义
               一种可以实现“先进后出”的存储结构，类似一叠盘子
           分类
                1.静态栈
                2.动态栈
           算法
                出栈
                入栈（压栈）
                
           应用
                函数调用
                中断
                表达式求值
                内存分配
                缓冲处理
                迷宫

        线性结构的两种常见应用之二 队列
           定义：
               一种可以实现“先进先出”的存储结构
           分类：
               链式队列————用链表实现

               静态队列————用数组实现
                   静态队列通常都必须是循环队列

                   循环队列的讲解：
                        1.静态队列为什么必须是循环队列
                        2.循环队列需要2个参数来确定
                           front
                           rear
                        3.循环队列各个参数的含义
                          2个参数不同场合含义不同
                             1）队列初始化
                                front和rear都设置为0
                             2）队列非空
                                front代表队列中的第一个元素
                                rear代表队列中的最后一个有效元素的下一个元素位置
                             3）队列为空
                                front和rear指向一个位置（不一定为0）
                        4.循环队列入队伪算法讲解
                            两步完成
                            1.将值传入r所代表的位置
                               错误的写法：rear = rear + 1;
                               正确的写法：rear = (rear + 1) % 数组长度;
                        5.循环队列出队伪算法讲解
                            front = (front + 1) % 数组长度;
                        6.如何判断循环队列是否为空
                            如果front和rear值相等则一定为空
                        7.如何判断循环队列是否已满
                            两种方式
                               1）增加一个标识参数
                               2）少用一个元素
                                        如果r和f的值紧挨着，则表明队列已满
                                        伪算法： if( (r+1)%数组长度 ==  f )
                                                {
                                                    已满
                                                }
                                                else
                                                {
                                                    未满
                                                }
                        队列的算法：    出队  入队
                        队列的具体应用：所有和时间有关的操作都有队列的影子
        专题： 递归（用到栈）
           定义： 一个函数直接或间接调用自己
              递归满足三个条件
                1、递归必须得有一个明确的中止条件
                2、该函数所处理的数据规模必须在递减
                3、这个转化必须是可解的

              循环和递归
                 递归:
                    易于理解
                    速度慢
                    存储空间大
                  循环：
                    不易理解
                    速度快
                    存储空间小

           函数的调用
            1.当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事:
            将所有的实际参数，返回地址等信息传递给被调函数保存

            2.为被调函数的局部变量(也包括形参)分配存储空间
            
            3.将控制转移到被调函数的入口
           
            从被调函数返回主调函数之前，系统也要完成三件事:
            1. 保存被调函数的返回结果

            2.释放被调函数所占的存储空间
            
            3.依照被调函数保存的返回地址将控制转移到调用函数
            
            当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之
            间信息传递和控制转移必须借助”栈”来实现，即系统将整个程序运行
            时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分
            配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储
            区，就行出栈操作，当前运行的函数永远都在栈顶位置
            A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只
            不过用我们日常的思维方式理解比较怪异而己!
            
           1.   求阶乘
           2.   1+2+3+4+……+100的和
           3.   汉诺塔
           4.   走迷宫
        递归的应用：
            树和森林就是以递归的方式定义的
            数和图的很多算法都是以递归来实现的
            很多数学公式就是以递归的方式定义的
                         菲波控契序列:  
    模块二： 非线性结构
         树
            树定义
               专业定义：
                    1.有且只有一个称为根的节点
                    2.有若干个不相交的子树，这些子树本身也是一颗树 
                通俗的定义：
                    1.树由节点和边（指针域）组成
                    2.每个节点只有一个父节点但可以有多个字节点
                    3.但有一个节点例外，该节点没有父节点，此节点称为根节点
                专业术语
                    1.节点： 父节点   子节点
                    2.子孙： 孩子   堂兄弟
                    3.深度： 从根节点到最低层节点的层数称之为深度
                            根节点是第一层
                    4.叶子节点：  没有子节点的节点
                    5.非终端节点：  非叶子节点
                    6.度：  子节点的个数

            树分类
                一般树
                    任意一个节点的子节点的个数都不受限制
                二叉树
                    任意一个节点的子节点个数最多两个，且子节点的位置不可变更
                    分类：  一般二叉树    满二叉树    完全二叉树
                森林
                    n个互不相交的树的集合
            树的存储
                二叉树的存储
                    连续存储[完全二叉树]
                        优点：
                            查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快
                        缺点：
                            耗用的内存空间过大
                    链式存储
                一般树的存储(无序存储的，一般树是无序的)
                          1.双亲表示法： 求父节点方便                              
                         ————————————
                       0 | A  | -1 |                   A
                       1 | B  |  0 |                /  |  \
                       2 | D  |  0 |               B   C   D
                       3 | E  |  4 |                    \
                       4 | C  |  0 |                      E
                       5 |    |    |
                       6 |    |    |
                         ————————————   

                          2.孩子表示法： 求子节点方便

                         ————————————————————
                         | A  | ->B->C->D   |                              A
                         | B  | ->E->F      |                           /  |  \
                         | C  |  NULL       |                          B   C   D
                         | D  | ->G         |                         / \     /  
                         | E  |  NULL       |                        E   F   G   
                         | F  |  NULL       |
                         | G  |  NULL       |
                         ————————————————————   

                          
                          3.双亲孩子表示法：求父节点和子节点都很方便

                         ———————————————————————
                       0 | E  | 4 |  NULL      |                            A
                       1 | F  | 4 |  NULL      |                           /  
                       2 | B  | 5 |  ->C       |                          B   
                       3 | D  | 4 |  NULL      |                           \      
                       4 | C  | 2 |  ->D->E->F |                            C     
                       5 | A  | 1 |  ->B       |                          / | \
                         ———————————————————————                         D  E  F

                          4.二叉树表示法：把一个普通树转化成二叉树来存储 【最终转化出来是没有 右子树的】
                              具体转化方法：
                                      设法保证任意一个节点左指针域指向它第一个孩子
                                      右指针域指向它兄弟
                                      只要能满足此条件，就可以把一个普通树转化为二叉树
                     &&懒得画图了：
【【郝斌】-数据结构入门】 【精准空降到 21:56】 https://www.bilibili.com/video/BV11s41167h6/?p=65&share_source=copy_web&vd_source=dcd3331de8ae63cb287316005a1d4c0d&t=1316
              
                森林的存储
                         和二叉树表示法类似
                         例： A B C 三个树的集合
                           把 B当A的兄弟 ，把 B当 C的兄弟
                       
                
            树操作
                遍历
                   先序遍历
                          中 左 右
                   中序遍历
                          左 中 右
                   后序遍历
                          左 右 中
                已知两种遍历序列，求原始二叉树（注：不是二叉查找树，那个右顺序的
                通过先序和中序 或者 中序和后序我们可以还原出原始的二叉树
                但是通过先序和后序是无法还原出原始的二叉树的
                   例： 先序：ABCDEFGH
                        中序：BDCEAFHG                                                                   A
                           求唯一确定的二叉树以及后序遍历： 后序为：DECBHGFA                               /  \
                             由先序可知 A 为根  所以中序中 BDCE A FGH A两边的都为子树                     B    F
                             有引文先序中B为第二个，所以B一定为根（子树的根）                              \     \
                             又因为中序中B先出现，所以B没有左子树 所以DCE是B的右子树                        C     G
                             先序中C先出现，所以B的右子树的根为C                                          / \    /
                             中序中C的左右分别为D和E所以 C的左孩子为D 右孩子为E                           D   E  H
                             再由先序可知F先出现，所以A的右子树根为F 
                             再由中序知道F没有左子树，HG为他的右子树
                             再由先序知道G在前，所以G为左子树的根
                             又因为中序中H在前，所以H为G的左儿子DECBHGFA

            应用：
                 树是数据库中数据组织的一种重要形式
                 操作系统子父进程的关系本身就是一棵树
                 面向对象语言中的继承关系本身就是一棵树                 
         图
    
    模块三： 查找和排序
        折半查找
        
        排序：
          冒泡
          插入
          选择
          快速排序
          归并排序
        排序和查找的关系
               排序是查找的前提
               排序的重点 
    Java中容器和数据结构相关知识
         Iterator接口
         Map
            哈希表


    再次讨论什么是数据结构 
            数据结构研究是数据的存储和数据的操作的一门学问数据的存储分为两部分: 
               个体的存储 
               个体关系的存储
               从某个角度而言，数据的存储最核心的就是个体关系的存储,个体的存储可以忽略不计
    再次讨论到底什么是泛型
           同一种逻辑结构，无论该逻辑结构物理存储是什么样的
           我们可以对它执行相同的操作
 */
#include <stdio.h>
#include <stdlib.h>
int main()
{
  
  
    system("pause");
    return 0;
}



