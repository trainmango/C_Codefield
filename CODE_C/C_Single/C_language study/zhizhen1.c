/* 
    2022年10月14日16点10分
 */
#include <stdio.h>
#include<stdlib.h>
int main()
{
    int *p;  //p是变量的名字，（int *）{是连在一起的}表示p变量存放的是int 类型变量的地址 
             //int *是数据类型 p才是名字
             //*p表示以p的内容为地址的变量
    int i = 3;  //i是普通变量
              //p存放的是整形变量地址

    p = &i;  //是对的
    // p = i; error,因为类型不一致，p只能存放int类型的变量地址，不能存放int类型变量的值
    // p = 55; error 原因同上
    printf("%d %d\n", i, *p);
    system("pause");
    return 0;
}

/* 先理解地址和数据，想象内存里面是一个个的小盒子，每个盒子对应一个编号，这个编号就是地址，盒子里存放的就是数据。

&是取地址运算符，如有 int a; 即有一个小盒子里面存放的数据起名叫a，&a就是取a的地址，即该盒子的编号。

*(地址)是取值运算符，这里*是解引用操作符，可以理解成打开对应地址编号的盒子，取出里面的数据。*(&a) 就是打开a对应的小盒子，取出里面的数据，即*(&a)和a等价。

我们定义一个指针变量int *p; p是指针变量，专门用来存放地址。

int *p=&a；相当于int *p; p=&a;

p存放的是a的地址，*p也等价于 a。指针变量p既然是变量，也同变量a一样对应一个小盒子，也有一个地址编号，&p就是取指针p的地址。这样就好理解二级指针了。

*p和**p的区别

int *p ：一级指针，表示p所指向的地址里面存放的是一个int类型的值

int **p ：二级指针，表示p所指向的地址里面存放的是一个指向int类型的指针（即p指向的地址里面存放的是一个指向int的一级指针）

例：

int a=5;     //定义整形变量
int *p=&a;   //定义一个指针指向这个变量
int **p1=&p; //定义一个二级指针指向p指针
/*   那么取出5的方式都有哪些呢？ */
/*
printf("a=%d",a);
printf("a=%d",*p);
printf("a=%d",**p1);
以上3行输出的值都是5 。

回过来看标题问题：*&p和&*p

根据运算优先级，*&p 等价于*(&p)。&*p 等价于&(*p)。

1、如果p是int *指针变量，那么*&p = p，&*p = p，都是p，但还没定义p指向哪，存的是谁的地址。

2、如果p是一个int变量，那么*&p = p；而&*p是非法的，因为*p非法。

比如int p =10；那么*&p = *(&p) = p = 10（即从p的地址取值），而&*p = &(*p) 则非法，因为p=10，*10是取内存地址为10的值，这在c语言中是不合法的。 */