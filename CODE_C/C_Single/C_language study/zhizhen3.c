/* 
      2022年10月17日15点29分
        指针：
          指针的重要性
             表示一些复杂的数据结构
             快速的传递数据，减少了内存的耗用
             使函数返回一个以上的值
             能直接访问硬件
             能够方便的处理字符串
             是理解面向对象语言中引用的基础
            
            总结： 指针是c语言的灵魂


            指针的定义
                     地址
                         内存单元的编号
                         从0开始的非负整数
                         范围：
                              例：4G：从0到4G-1
                              例：双8G（16G）从高0到16G-1

            例：地址线 32根 即32位系统
                   能控制2的32次方个单元 即2的32次方=2的30次方*2的2次方=4G 理论上32位最大控制4G内存
                   一个单元(字节)8位为1B = 8bit
                   即2的32次方乘8位
                   1K=2的十次方B
                   1M=2的十次方KB=2的二十次方B
                   1G=1024M=2的三十次方B
                  所以理论上64位：2的64次方=2的30次方*2的32次方*2的2次方=2的34次方G


                     指针
                         指针就是地址，地址就是指针
                         指针变量就是存放内存单元编号的变量，或者说指针变量就是存放地址的变量
                         指针和指针变量是个不同的概念
                         但是要注意： 通常我们叙述时会把指针便改良统称为指针，实际它们含义不一样
                         指针的本质就是一个操作受限额非负整数（是个编号所以非负）






            指针的分类
                     1.基本类型指针
                        #include <stdio.h>
                        #include<stdlib.h>
                        int main()
                        {
                            int * p;  //p是指针变量 能存放其他变量地址的变量 int *是数据类型 p才是名字
                                      //所谓int *类型  实际就是存放int变量地址的类型
                            int i = 3;  //i是普通变量

                            p = &i;  
                            /* 
          p保存了i的地址，因此p指向i  
          p不是i， i也不是p， 更准确的说： 修改p的值不影响i的值，修改i的值也不会影响p的值
          指针变量就是存放地址的变量。
          如果一个指针变量指向了某个普通变量，则
          *指针变量 就完全等同于 普通变量
             例子：
                如果p是一个指针变量，并且p存放了普通变量i的地址
                则p指向了普通变量i
                *p 就完全等同于 i
                或者说： 在所有出现*p的地方都可以替换成i
                        在所有出现i的地方都可以替换成*p
                *p 就是以p的内容为地址的变量(此例为p取了i的地址)
                 
                指针就是地址，地址就是指针
                地址就是内存单元的编号
                指针变量是存放地址的变量（此例中p为指针变量）
                指针（地址）和指针变量（指针变量是变量。定义一个指针变量，是在内存中开辟一个空间，该空间里面存放地址。）是个不同的概念
                但是要注意： 通常我们叙述时会把指针变量统称为指针，实际它们含义不一样
                
                  例：
                    int * p = &a;  //定义了指针变量p   （int * 是数据类型，p为变量名）
                    p = &b;  //将b的地址放在p的空间
                    int *q = p;  //定义了指针变量q，把p的内容（地址）给了q（空间）


      
    system("pause");
    return 0;
}





                附注：
                    *的含义
                          1.乘法
                          2.定义指针变量 
                            int * p;
                            //定义了一个名字叫p的变量，int *表示p只能存放int变量的地址
                          3.指针运算符(取地址的逆运算符，解引用操作符，取值运算符)
                              该运算符放在已经定义好的指针变量的前面
                              如果p是一个已经定义好的指针变量
                              则*p表示 以p的内容为地址的变量（指针变量p所指向的对象）
                      如何通过被调函数修改主调函数普通变量的值
                          1.实参必须为改普通变量的地址
                          2，形参必须为指针变量
                          3.在被调函数中通过
                               *形参名 = ......
                            的方式就可以修改主调函数相关变量的值
*/
/*

                     2.指针和数组
                         指针和一维数组
                           一维数组名
                             一维数组名是个指针常量
                             它存放的是一维数组第一个元素的地址

                           下标和指针的关系
                               如果p是个指针变量，则
                                p[i] 永远等价于 *(p+i)
                                确定一个一维数组需要几个参数【如果一个函数要处理一个以为数组，则需要接受该数组的哪些信息】
                                  需要两个参数：
                                          数组第一个元素的地址
                                          数组的长度

                           指针变量的运算
                                 指针变量不能想加 不能相乘 也不能相除 
                                 如果两个指针变量指向的是同一块连续空间中的不同存储单元， 
                                 则这两个指针变量才可以相减
                           一个指针变量到底占几个字节（去看*****zhizhen17.c******）
                                 预备知识：
                                         sizeof(数据类型)
                                         功能：返回值就是该数据类型所占的字节数
                                         例子：sizeof(int) = 4 sizeof(char) = 1
                                               sizeof(double) = 8

                                           sizeof(变量名)
                                           功能：返回值是该变量所占字节数
                                 假设p指向char类型变量(1个字节)
                                 假设q指向int类型变量(4个字节)
                                 假设r指向double类型变量(8个字节)
                                 p q r 本身所占的字节数是否一样?
                                总结：
                                     一个指针变量，无论他它指向的变量占几个字节
                                     该指针变量本身占8个字节（是以编译器 内存条来看的）
                                     
                                     一个变量的地址使用该变量首字节的地址来表示的

                           指针和二维数组
                     3.指针和函数

                     4.指针和结构体
                       

                     5.多级指针



                  专题：
                       动态内存分配
                          传统数组的缺点：
                            1.数组长度必须事先制定，且只能是常整数，不能是变量
                             例子：
                                int a[5];  //ok
                                int len = 5; int a[len]; //error ,a[]大括号里边不能是常量

       (去看zhizhen18.c)    2.传统形式定义的数组，该数组的内存程序员无法手动释放
                            数组一旦定义，系统会为该数组分配存储空间就会一直存在，
                            在一个函数运行期间，系统为该函数中数组所分配的空间会
                            一直存在，直到该函数运行完毕时，数组的空间才会释放
                            
                            3.数组的长度一旦被定义，其长度就不能再更改
                              数组的长度不能在函数运行的过程中动态的扩充或缩小 

                            4.A函数中定义的数组，在A函数运行期间可以被其他函数使用，
                              但A函数运行完毕之后，A函数中的数组将无法在被其他函数使用，
                              传统方式定义的数组不能跨函数使用
                               
                    为什么需要动态分配内存
                        动态数组很好的解决了传统数组的4个缺陷
                        传统数组也叫静态数组



                    动态内存分配举例_ 动态数组的构造
                          
                    静态内存和动态内存的比较
                          
                    跨函数使用内存的问题
                
           结构体
               为什么需要结构体
                   为了表示一些复杂的事物，而普通的基本类型无法满足实际需要
               什么叫结构体
                   把一些基本类型数据组合在一起形成的一个新的符合数据类型，这个叫结构体
               如何定义结构体
                   3种方式，推荐使用第一种方式
                   //第一种定义方式  这只是定义了一个新的数据类型，并没有定义变量
                  struct Student 
                  {
                    int age;
                    float score;
                    char sex;
                  };
                  //第二种定义方式
                  struct Student2 
                  {
                    int age;
                    float score;
                    char sex;
                  } st2;
                  //第三种定义方式
                  struct 
                  {
                    int age;
                    float score;
                    char sex;
                  } st3;
               怎么使用结构体变量

                    赋值和初始化
                       定义的同时可以整体赋初值
                       如果定义完之后则只能单个的赋初值

                    如何取出结构体变量中的每一个成员【重点】
                       1.结构体变量名.成员名
       【第2种更常用】  2.指针变量名->成员名  【在计算机内部会被转化成(*指针变量名).成员名的方式来执行】
                                               所以说这两种方式是等价的
                       例子：
                            #include <stdio.h>
                            #include<stdlib.h>
                            struct Student 
                            {
                              int age;
                              float score;
                              char sex;
                            };
                            int main()
                            {
                                struct Student st = {80, 66.6, 'F'};
                                struct Student * pst = &st;   //&st不能改成st
                                st.age = 10; //第一种取出方式
                                pst->age = 88; //第二种取出方式
                                system("pause");
                                return 0;
                            }
                                 注：1. pst->age 在计算机内部会被转化成(*pst).age  这就是->的含义，这也是一种硬性规定  
                                     2. 所以pst->age等价于(*pst).age也等价于st.age
                                     3. 我们只所以知道pst->age等价于st.age是因为pst->age是被转化成了(*pst).age来执行
                                     4. pst->age 的含义：pst所指向的那个结构体变量中的age这个成员

                    结构体变量和结构体变量指针作为函数参数传递的问题
                                    推荐使用结构体指针变量作为函数参数来传递

                       
                    结构体变量的运算
                              结构体变量不能相加，不能相减，也不能相互乘除
                              但结构体可以相互赋值
                          例：
                             struct Student
                             {
                                int age;
                                char sex;
                                char name[100];
                             };  //分号不能省略
                             struct Student st1, st2;
                             //st1 + st2 st1*st2 st1/st2 都是错的
                             // st1 = st2   或者st2 = st1   都是正确的
                    
                          
                      举例：
                         动态构造存放学生信息的结构体数组
                            动态构造一个数组，存放学生信息
                            然后按分数排序输出
  
                    枚举
                        什么是枚举
                              把一个事物所有可能的值一一列举出来

                        怎么使用枚举
                               

                        枚举的优缺点
                             代码更安全 
                             书写麻烦
                专题：
                    补码： 
                        原码
                          也叫符号-绝对值码
                          最高位0表示正 1表示负，其余二进制位是该数字的绝对值的二进制位
                          
                          原码简单易懂
                          加减运算复杂
                          存在加减乘除四种运算，增加了CPU的复杂度
                          零的表示不唯一


                        反码
                          反码运算不便，也没有在计算机中应用
                          


                        移码
                          移码表示数值平移n位，n称为移码量
                          移码主要用于浮点数的阶码的存储


                        补码
                          已知十进制求二进制
                              求正整数的二进制
                                 除2取余，直至商为零，余数倒叙排序
                              
                              求负整数的二进制
                                 先求与该负数相对应的正整数的二进制代码，然后将
                                 所有位取反，末尾加1，不够位数时，左边补零
                                   例： （-3）  二进制位011
                                              取反     100
                                              末尾加一  101
                                      若在int中，【int有32位】即
                                       （+3）    0000....0011  【int有4个字节4*8=32位】
                                       （-3）    1111....1101  【32位】

                              求零的二进制
                                  000000....000 即全是零
                          
                          已知二进制求十进制
                               如果首位是0，则表明是正整数，按普通方法来求


                               如果首位是1，则表明是负数
                                       将所有位取反，末尾加一，所得数字就是该负数的绝对值
                                       先减一再取反也可以得到负数的绝对值
                               
                               如果全是零，则对应的十进制数字就是零
                              


                        
                         学习目标：
                              在此编译器中一个int类型的变量所能存储的数字的范围是多少
                                  int类型变量所能存储的最大正数用十六进制表示是：7FFFFFFF 即0111 1111 1111 1111 1111 1111 1111 1111
                                  int类型变量所能存储的绝对值最大的负整数用十六进制表示是：80000000


                              最小负数的二级制代码是多少
                              最大整数的二级制代码是多少
                              已知一个整数的二进制代码求出原始数字
                              数字超过最大正数会怎样 
                              不同类型数据的相互转化



                    进制转换【云记】

                    字符串处理
  
                    链表：
                         算法：
                             通俗定义：
                                  解题的方法和步骤

                             狭义定义：
                                  对存储数据的操作
                                  对不同的存储结构，要完成某一功能所执行的操作是不一样的
                                  比如：
                                      要输出数组中所有的元素的操作和
                                      要输出链表中所有元素的操作肯定是不一样的
                                  这说明：
                                       算法是依附于存储结构的
                                       不同的存储结构，所执行的算法是不一样的


                             广义定义：  
                                  广义的算法也叫泛型
                                  无论数据是如何存储的，对该数据的操作都是一样的
                      
                      我们至少可以通过两种结构来存储数据
                           数组
                             优点：
                                 存取速度快
                             缺点：
                                 需要一个连续的很大的内存
                                 插入和删除元素效率低

                           链表
                            专业术语：
                                 首结点
                                     存放第一个有效数据的节点
                                 尾结点
                                     存放最后一个有效数据的节点
                          
                                 头结点
                                     头结点的数据类型和首节点的类型是一模一样的
                                     头结点是首节点前面的那个结点
                                     头结点并不存放有效数据
                                     设置头结点的目的是为了方便对链表的操作
                                 头指针
                                     存放头结点地址的指针变量
                                确定一个链表需要一个参数：头指针
                                                


                              优点：
                                插入删除元素效率高
                                不需要一个连续的很大的内存
                              缺点：
                                查找摸个位置的元素效率低
                          
                          位运算符：
                            & -----  按位与
                                  && 逻辑 与  也叫 并且 且
                                  && 与 & 的含义完全不同
                                  1&1 = 1   5&7 = 5
                                  1&0 = 0   21&7 = 5
                                  0&1 = 0   5&1 = 1
                                  0&0 = 0   5&10 = 0
                                

                            | ----  按位或
                                ||  逻辑或
                                |   按位或
                                1|0 = 1
                                1|1 = 1
                                0|1 = 1
                                0|0 = 0

                            ~ ----  按位取反
                               ~i就是把i变量所有的二进制位取反
                            
                            ^ --- 按位异或
                               相同为0
                               不同为1
                               1^0 = 1
                               0^1 = 1
                               1^1 = 0
                               0^0 = 0

                            << --- 按位左移
                                 i<<1 表示把i的所有二进制位左移一位
                                 i<<3 表示把i的所有二进制位左移三位，右边补零
                                 左移n位相当于乘以2的n次方
                                   例： 面试题：
                                      A）  i = i*8;
                                      B）  i = i<<3;
                                        请问上述两个语句，那个语句执行的速度快
                                        答案：B



                            >> --- 按位右移
                                 i>>1 表示把i的所有二进制位右移一位，左边一般是补零也可能补一（负数）
                                 i>>3 表示把i的所有二进制位右移三位，左边一般是补零也可能补一（负数）
                                 右移n位相当于除以2的n次方，前提是数据不能丢失
                                    例： 面试题：
                                      A）  i = i/8;
                                      B）  i = i>>3;
                                        请问上述两个语句，那个语句执行的速度快
                                        答案：B

                             位运算符的显示意义
                                 通过位运算符我们可以对数据的操作精准到每一位

                      二进制全部为零的含义 ---- 0000000000000的含义
                             1.数值零
                             2.字符串结束标记符'\0'
                             3.空指针NULL
                               NULL本质也是零，而这个零不代表数字零，而表示的是内存单元的编号零

                               我们计算机规定了，以零为编号的存储单元的内容不可读，不可写 



                          


 */
#include <stdio.h>
#include<stdlib.h>
int main()
{
    int i = 5;
    int * p;
    int * q;

    p = &i;
   
    // *q = p;    error,编译有问题
    // p = q;   q是垃圾值，q赋给p，p也变成垃圾值
    printf("%d\n", *q);   /* 
                             q的空间是属于本程序的，所以本程序可以读写q的内容，
                             但是如果q的内部是垃圾值，则本程序不能读写*q的内容
                             因为此时*q所代表的内存单元的控制权限并没有分配给本程序
                            */
    system("pause");
    return 0;
}